<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  margin: 0;
}

.button {
  outline: none;
  display: block;
  width: 100px;
  padding: 6px 0;
  text-align: center;
  border: 1px solid #ddd;
  border-bottom: 1px solid #aaa;
  border-right: 1px solid #aaa;
  background-color: #ccc;
  background-repeat: repeat-x;
  background-position: left top;
  font-size: 14px;
  text-shadow: 1px 1px 1px #fff;
  font-weight: bold;
  height: 22px;
  line-height: 1.5em;
  margin-bottom: 6px;
}

path {
  fill: none;
  stroke: #000;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.major_road { stroke: #776; }
.minor_road { stroke: #ccb; }
.highway { stroke: #f39; stroke-width: 1.5px; }
.rail { stroke: #7de; }


</style>
<body>
  <div class='readout'></div><br>
  <a class="button" id='prunebutton'>prune</a>
  <a class="button" id='resetbutton'>reset</a>
  <a class="button" id='drawrawbutton'>draw raw</a>
  <a class="button" id='drawrawmutatedbutton'>draw mutated</a>
<script src="js/d3.v3.js"></script>
<script src="js/d3.geo.tile.v0.min.js"></script>
<script src="js/graphlib.js"></script>
<script>


// object for storing and working with geojson
var GeojsonBucket = function(uid) {
  this.uid = uid || 'mapdata'; // used when storing and retrieving locally
  this.json = {};
  this.length = 0;
  this.featuresToJoin = {};
  // this.self = this;

  // console.log('initing geojsonBucket');
  // console.log('done initing geojsonBucket');
};

GeojsonBucket.prototype.compareCoordinates = function(a,b) {
  return ((a[0] === b[0]) && (a[1] === b[1]));
};
  // joins two arrays of coordinates, as long as one has a head that matches the other's tail

GeojsonBucket.prototype.joinCoordinateArrays = function(a,b,      j,d) {
  var joined;
// if (j.id == '6530058') {
//   debugger
// }

  if (this.compareCoordinates(a[0], b[b.length - 1]) === true) {
    joined = b.concat(a.slice(1));
console.log('id: '+j.id+' a: '+a+' b: '+b+' joined: ' + joined);
    return joined;
  } else if (this.compareCoordinates(b[0], a[a.length - 1]) === true) {
    joined = a.concat(b.slice(1));
console.log('id: '+j.id+' a: '+a+' b: '+b+' joined: ' + joined);
    return joined;
  } else {
console.log('id: '+j.id+' a: '+a+' b: '+b+" Couldn't join arrays");
    return false;
  }
};
GeojsonBucket.prototype.saveToDisk = function() {
  console.log('saving uid: ' + this.uid + ' json size: ' + this.length);
  localStorage.setObject(this.uid, this.json);
};
GeojsonBucket.prototype.loadFromDisk = function() {
  var tempJson;
  tempJson = localStorage.getObject(this.uid);
  if (tempJson === null) {
    console.log("Couldn't read data from local storage with key '" + this.uid +"'");
  } else {
    this.json = tempJson;
    this.length = Object.keys(tempJson).length;
    console.log('loading uid: "' + this.uid + '", json size: ' + Object.keys(this.json).length);
  }
  // should do some sanity checks on data returned
};

// adds a new feature to the json, checking to see if it can be appended to an existing path
GeojsonBucket.prototype.add = function add(f) {
    var id = f.id;
    console.log('adding ' + id);
// debugger;
    // if the new feature is a continuation of a feature we already have, join them
    if (this.json[id] === undefined) {
console.log('adding '+id+' for the first time');
      this.json[id] = f;
      length += 1;
    } else {
      if (this.featuresToJoin[id] === undefined) {
        this.featuresToJoin[id] = [f];
      } else {
        this.featuresToJoin[id].push(f);
      }
var pendingFeatures=this.featuresToJoin[id].length;
var pendingCoordinates=this.featuresToJoin[id].reduce(
  function(prev, curr) {
   return prev.concat(curr.geometry.coordinates);
 },[]).length;
var integratedCoordinates=this.json[id].geometry.coordinates.length;
  // need to join ways together that have been split over multiple tiles
      console.log('id already stored (coords ' + this.json[id].geometry.coordinates.length + '). additional coords: ' + f.geometry.coordinates.length + '. total arrays to join: ' + (1 + this.featuresToJoin[id].length));
      var arrayJoined = true;
      // we want to loop over our this.featuresToJoin repeatedly while joins are successful, because the last join may enable the next
      while ((this.featuresToJoin[id].length > 0) && (arrayJoined === true)) {
// console.log('in while, this.featuresToJoin[id].length = '+this.featuresToJoin[id].length);
        arrayJoined = false;
        for (var i=0,  potentialSegments=this.featuresToJoin[id].length; ((i < potentialSegments) && (arrayJoined === false)); i++) {
// console.log('in for, potentialSegments='+potentialSegments+' i='+i);
          var joined = this.joinCoordinateArrays(this.json[id].geometry.coordinates, this.featuresToJoin[id][i].geometry.coordinates,       this.json[id], f);
          if (joined.constructor === Array) { // if our join succeeded
// console.log('woohoo ' + joined + ' totallen = ' + this.json[id].geometry.coordinates.length);
            arrayJoined = true;
            this.json[id].geometry.coordinates = joined.slice(); // use slice copy the array, not just a reference
console.log('this.featuresToJoin[id] len: '+this.featuresToJoin[id].length+' before');

// debugger
            this.featuresToJoin[id] = this.featuresToJoin[id].splice(i,1); // remove original copy of the now-joined array

console.log('this.featuresToJoin[id] len: '+this.featuresToJoin[id].length+' after');
console.log('json entries: '+ Object.keys(this.json).length + ', length: '+this.length)+' (numbers should match)';
// console.log('woohoo ' + joined + ' totallen = ' + this.json[id].geometry.coordinates.length);
          // } else {
  // debugger
}

        }
      }
var newPendingFeatures=this.featuresToJoin[id].length;
var newPendingCoordinates=this.featuresToJoin[id].reduce(
  function(prev, curr) {
   return prev.concat(curr.geometry.coordinates);
 },[]).length;
var newIntegratedCoordinates=this.json[id].geometry.coordinates.length;
console.log('old: pending features: '+pendingFeatures+', pending coords: ' + pendingCoordinates+', current coords: '+integratedCoordinates);
console.log('new: pending features: '+newPendingFeatures+', pending coords: ' + newPendingCoordinates+', current coords: '+newIntegratedCoordinates);
// if (x > 1) debugger
    }
    length += 1;
// debugger;
    this.saveToDisk();
};
GeojsonBucket.prototype.remove = function remove(d) {
  delete this.json[d.id];
  this.length -= 1;
};
GeojsonBucket.prototype.reset = function reset() {
  this.json = {};
  this.featuresToJoin = {};
  this.length = 0;
};
// sorted array
GeojsonBucket.prototype.array = function array() {
  var arr = Object.keys(this.json).map( function (key) {
    return this.json[key];
  }.bind(this));
  return arr.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; });
};
// mutate: function mutate() { // should return mutated data
//   console.log("not sure how to how to mutate raw json yet. for now renturning raw data.");
//   var a = this.get();
//   return this.get();
// },
GeojsonBucket.prototype.get = function() {
  return this.array();
};
GeojsonBucket.prototype.debug = function() {
  debugger;
};
GeojsonBucket.prototype.print = function() {
  var j = this.json;
  var k = Object.keys(j);
  var nodeCounter = 0;
  k.forEach(
    function (f) {
      console.log(
        'id:'+j[f].id+' kind:'+j[f].properties.kind+' ['+j[f].geometry.coordinates.map(
          function(c) {
            nodeCounter += 1;
            return c.toString();
          }
        ).join('] , [')+']'
      );
    }
  );
  console.log('json entries: ' + k.length);
  console.log('nodes: ' + nodeCounter);
};
GeojsonBucket.prototype.printPending = function() {
  var j = this.featuresToJoin;
  var uids = Object.keys(j);
  var fragCounter = 0;
  var coordCounter = 0;
  uids.forEach(
    function (uid) {
      j[uid].forEach(
        function (fragment) {
          var coords = fragment.geometry.coordinates;
// debugger
          fragCounter += 1;
          coordCounter += coords.length;
          console.log(
            'id:'+fragment.id+' kind:'+fragment.properties.kind+' ['+coords.map(
              function(c) {
                return c.toString();
              }
            ).join('] , [')+']'
          );
        }
      );
    }
  );
  console.log('unique feature ids: ' + uids.length);
  console.log('remaining feature fragments to join: '+fragCounter);
  console.log('total coordinates: ' + coordCounter);
};



illumap = function (context) {
  // Global vars
var holder = {};

  var svgElement = "bob",
      // mapCenter = [6.17,53.475],
      // mapZoomLevel = 23,
      mapCenter = [6.17,53.475],
      mapZoomLevel = 26,
      tileCache = {},
      newFeatures = false, // flag for testing whether we have to re-mutate our raw features
      rawDataContainer = d3.select('body').append("custom"); // DOM container for raw elements

  var width = Math.max(960, window.innerWidth),
      height = Math.max(500, window.innerHeight);

  // Tool to determine what tiles are in the view based on scale, size, projection, and translation
  var d3tiler = d3.geo.tile()
      .size([width, height]);

  var d3projection = d3.geo.mercator()
      .center(mapCenter)
      .scale((1 << mapZoomLevel) / 2 / Math.PI)
      .translate([width / 2, height / 2]);

  // Given a geometry or feature object, d3.geo.path generates the path data string suitable for the "d" attribute of an SVG path element
  var d3path = d3.geo.path()
      .projection(d3projection);

  // var d3line = d3.svg.line();

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);


  /////////////////////
  // Utility functions

  // produces a UID for tile coordinates
  var tileId = function tileId(t) {
    return t.join('.');
  };

  function clone(obj) {
    if(obj === null || typeof(obj) !== 'object' || 'isActiveClone' in obj)
        return obj;
    var temp = obj.constructor(); // changed
    for(var key in obj) {
        if(Object.prototype.hasOwnProperty.call(obj, key)) {
            obj.isActiveClone = null;
            temp[key] = clone(obj[key]);
            delete obj.isActiveClone;
        }
    }
    return temp;
  }

  // object merge
  function merge() {
    var obj = {},
        i = 0,
        il = arguments.length,
        key;
    for (; i < il; i++) {
        for (key in arguments[i]) {
            if (arguments[i].hasOwnProperty(key)) {
                obj[key] = arguments[i][key];
            }
        }
    }
    return obj;
  }


  // Extend localStorage
  Storage.prototype.setObject = function(key, value) {
      this.setItem(key, JSON.stringify(value));
  };

  Storage.prototype.getObject = function(key) {
      var value = this.getItem(key);
      try {
          JSON.parse(value);
      }
      catch(e) {
          console.log('data stored locally in "mapdata" is invalid JSON:');
          console.log(value);
          return false;
      }
      return value && JSON.parse(value);
  };






  // Module to store map data, a graph from it, and do all the manipulations
  var data = function data() {

    var rawData,
      geojsonBucket = new GeojsonBucket('rawdata'),  // module that holds raw data
      mutatedData = [],
      mutationSequence = [],  // list of changes performed on data
      mapg = new graphlib.Graph({ directed: false, multigraph: true });
    // loads tiles in current view and adds the geojson to our data store
    var loadGeojsonFromServer = function loadGeojsonFromServer() {
        geojsonBucket.reset();
        d3tiler    // Generates tile coordinates in current view
          .scale(d3projection.scale() * 2 * Math.PI)
          .translate(d3projection([0, 0]))()
          .forEach(function(t) {   // download and display each vector tile
            var tid = tileId(t);
            console.log('need to get tile ' + tid);
            var tileserver = "http://" + ["a", "b", "c"][(t[0] * 31 + t[1]) % 3] + ".tile.openstreetmap.us";
            var tileurlpath = "/vectiles-highroad/" + t[2] + "/" + t[0] + "/" + t[1] + ".json";
            d3.json( tileserver + tileurlpath , function(error, json) {  // this is asynchronous
              tileCache[tid] = json;
              // 'json' is a FeatureCollection object containing an array of Feature objects
              json.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }) // sort it so our join-by-index is consistent
                .forEach(function(f) { // for each feature
                  geojsonBucket.add(f);
                  console.log('retrieved tile ' + tid + ', features: ' + json.features.length);
                });
           });
          });
    };



    var loadGeojsonFromLocal = function loadGeojsonFromLocal() {
      geojsonBucket.reset();
      geojsonBucket.loadFromDisk();
    };


    // 'data' return
    return {
      rawData: rawData,
      geojsonBucket: geojsonBucket,  // module that holds features in current view (should we directly modify contents, or feed into something else?)
      mutatedData: mutatedData,
      mutationSequence: mutationSequence,  // list of changes performed on data

      init: function init() {
        console.log('initing data');
        // var defaults = {source: 'local'};
        var defaults = {};
        var opts = merge(defaults, (arguments[0] || {}));
        switch (opts.source) {
          case "server":
            loadGeojsonFromServer();
            break;
          case "local":
            loadGeojsonFromLocal();
            break;
          default:
            loadGeojsonFromLocal();
            if (geojsonBucket.length === 0) {
              console.log("Couldn't load data from disk. Loading from server");
              loadGeojsonFromServer();
            }
          }
        console.log("data inited. loaded from " + opts.source);
      },

      debug: function () {
        debugger;
      },

      loadRawData: function loadRawData(data) {
        rawData = clone(data);
        mutatedData = clone(data); // same object without clone! argh
        return rawData;
      },

      // returns geojsonBucket as array
      getRawData: function getRawData() {
        return geojsonBucket.array();
      },

      getMutatedData: function getMutatedData() {
        geojsonBucket.mutate();  // should actually load data from graph object
        return mutatedData;
      },

      mutate: function mutate() {
        var arr = geojsonBucket.array();
        var randomNode = arr[getRandomInt(0, arr.length)];
        geojsonBucket.remove(randomNode);
        console.log('mutated by removing ' + del.id + '. ' + geojsonBucket.length() + ' paths remain');
      },

      prune: function prune() {
        // debugger;
        var p = mutatedData.pop();
        var action = {
          pruned: p
        };
        mutationSequence.concat(action);
        console.log('pruned ' + p);
        console.log('remaining ' + mutatedData);
        console.log('rawData ' + rawData);
      },

      reset: function reset() {
        mutationSequence = [];
        rawData = clone(geojsonBucket.json);
        mutatedData = clone(geojsonBucket.json);
        console.log('reset data to ' + rawData);
      }

    };

  }();






  // Module to draw svg based on data being passed in
  var graphics = function graphics() {
    // Phase1: retrieve the tiles in the view, pass them to the data object
    // Phase1: draw the data from the data object
    // Phase2: add event handling for scrolling and zooming, retrieve new data (and pass it to the data module), and update the display area with modified data from the data module

    var svgClear = function svgClear() {
      svg.selectAll("*").remove();
    };

    var svgDraw = function svgDraw(paths) {
      console.log('drawing ' + paths.length + ' paths');
// debugger;
      svgClear();
      svg.selectAll("path")  // get all the svg paths from this svg grouping
          .data(paths)
        .enter().append("path")
          .attr("class", function(d) { return d.properties.kind; })
          .attr("d", d3path)
          // .each(function(f) { // for each feature
          //   console.log('drawing path with ' + f.geometry.coordinates.length + ' nodes');
          // })
          ;
    };

    var svgDrawRaw = function svgDrawRaw() {
      var paths = data.getRawData();
      console.log('drawing ' + paths.length + ' paths from raw data');
      svgDraw(paths);
    };


    var svgDrawMutated = function svgDrawMutated() {
      var paths = data.getMutatedData();
      console.log('drawing ' + paths.length + ' paths from mutated data');
      svgDraw(paths);
    };

    function draw(dataArg) {
        if (dataArg === undefined) {
          console.log('no data passed to draw. defaulting to mutated data (data.getMutatedData)');
          dataArg = illumap.data.getRawData();
        }
        var selection = svg.selectAll("path")
              .data(dataArg)
              // .data([data], function(d) { return ''+d; })
              .attr('d', d3path)
              .each(function(d) {
                console.log('update: ' + d );
              });
        selection.enter().append('path')
              .attr("stroke", "black")
              .attr("fill", "none")
              .attr("stroke-width",2)
              .attr('d',d3path)
              .each(function(d) {
                console.log('enter: ' + d);
              });
        selection.exit().each(function(d) {
          console.log("exit: "+ d);
        });
      }






    return {
      draw: draw,
      svgDrawRaw: svgDrawRaw,
      svgDrawMutated: svgDrawMutated,
      svgClear: svgClear,

      // init: store passed in svg element.
      // draw: take data and draw it, using module parameters
      init: function init() {
        console.log('graphics inited');
        return svg;
      },

      debug: function () {
        debugger;
      },

    }; // end return
  }(); // end graphics



  // Module to run tests
  var test = function test() {
    // var tempdata = [[1,1],[2,2],[2,3],[3,3],[3,4]];

    // var tempmapdata =
    // .data(d3tiler
    //   .scale(d3projection.scale() * 2 * Math.PI)
    //   .translate(d3projection([0, 0])))

    // init: store passed in svg element.
    var init = function init() {
      // debugger;
      // illumap.data.init({source: 'local'});
      illumap.data.init();
      // illumap.data.loadRawData();
      // illumap.updateTiles();
      illumap.graphics.init();
      // illumap.graphics.draw(illumap.data.getRawData());
      illumap.graphics.svgClear();
      illumap.graphics.svgDrawRaw();
// debugger;
    };

    return {
      init: init
    }; // end return
  }(); // end test

// debugger;
  window.addEventListener('load', test.init);

  var debug = function() {
    debugger;
  };

  // API
  return {
    data: data,
    graphics: graphics,
    test: test,
    debug: debug

  };



}(this);


var testbutton = d3.select('#prunebutton')
  .on('click', illumap.data.mutate);
d3.select('#resetbutton')
  .on('click', illumap.data.reset);
d3.select('#drawrawbutton')
  .on('click', illumap.graphics.svgDrawRaw);
d3.select('#drawrawmutatedbutton')
  .on('click', illumap.graphics.svgDrawMutated);

</script>

</body>
</html>
