<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  margin: 0;
}

.button {
  outline: none;
  display: block;
  width: 100px;
  padding: 6px 0;
  text-align: center;
  border: 1px solid #ddd;
  border-bottom: 1px solid #aaa;
  border-right: 1px solid #aaa;
  background-color: #ccc;
  background-repeat: repeat-x;
  background-position: left top;
  font-size: 14px;
  text-shadow: 1px 1px 1px #fff;
  font-weight: bold;
  height: 22px;
  line-height: 1.5em;
  margin-bottom: 6px;
}

path {
  fill: none;
  stroke: #000;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.major_road { stroke: #776; }
.minor_road { stroke: #ccb; }
.highway { stroke: #f39; stroke-width: 1.5px; }
.rail { stroke: #7de; }


</style>
<body>
  <div class='readout'></div><br>
  <a class="button" id='prunebutton'>prune</a>
  <a class="button" id='resetbutton'>reset</a>
  <a class="button" id='drawbutton'>draw</a>
<script src="js/d3.v3.js"></script>
<script src="js/d3.geo.tile.v0.min.js"></script>
<script src="js/graphlib.js"></script>
<script>


illumap = function (context) {
  // Global vars
var holder = {};

  var svgElement = "bob",
      mapCenter = [6.17,53.475],
      mapZoomLevel = 23,
      tileCache = {},
      newFeatures = false, // flag for testing whether we have to re-mutate our raw features
      rawDataContainer = d3.select('body').append("custom"); // DOM container for raw elements

  var width = Math.max(960, window.innerWidth),
      height = Math.max(500, window.innerHeight);

  // Tool to determine what tiles are in the view based on scale, size, projection, and translation
  var d3tiler = d3.geo.tile()
      .size([width, height]);

  var d3projection = d3.geo.mercator()
      .center(mapCenter)
      .scale((1 << mapZoomLevel) / 2 / Math.PI)
      .translate([width / 2, height / 2]);

  // Given a geometry or feature object, d3.geo.path generates the path data string suitable for the "d" attribute of an SVG path element
  var d3path = d3.geo.path()
      .projection(d3projection);

  // var d3line = d3.svg.line();

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);


  /////////////////////
  // Utility functions

  // produces a UID for tile coordinates
  var tileId = function tileId(t) {
    return t.join('.');
  };

  function clone(obj) {
    if(obj === null || typeof(obj) !== 'object' || 'isActiveClone' in obj)
        return obj;
    var temp = obj.constructor(); // changed
    for(var key in obj) {
        if(Object.prototype.hasOwnProperty.call(obj, key)) {
            obj.isActiveClone = null;
            temp[key] = clone(obj[key]);
            delete obj.isActiveClone;
        }
    }
    return temp;
  }

  function merge() {
    var obj = {},
        i = 0,
        il = arguments.length,
        key;
    for (; i < il; i++) {
        for (key in arguments[i]) {
            if (arguments[i].hasOwnProperty(key)) {
                obj[key] = arguments[i][key];
            }
        }
    }
    return obj;
  }

  // Extend localStorage
  Storage.prototype.setObject = function(key, value) {
      this.setItem(key, JSON.stringify(value));
  };

  Storage.prototype.getObject = function(key) {
      var value = this.getItem(key);
      try {
          JSON.parse(value);
      }
      catch(e) {
          console.log('data stored locally in "mapdata" is invalid JSON:');
          console.log(value);
          return false;
      }
      return value && JSON.parse(value);
  };






  // Module to store map data, a graph from it, and do all the manipulations
  var data = function data() {
    //Phase1: input, storage of original tiles and vectors, output, simple modification
    //Phase2: more complex modification, action history for repetition

    // raw tiles
    // agregated geojson
    var rawData,
      geojsonBucket,  // module that holds features in current view (should we directly modify contents, or feed into something else?)
      mutatedData = [],
      mutationSequence = [];  // list of changes performed on data

    var g = new graphlib.Graph();

    // loads tiles in current view and adds the geojson to our data store
    var loadGeojsonFromServer = function loadGeojsonFromServer() {
        d3tiler    // Generates tile coordinates in current view
          .scale(d3projection.scale() * 2 * Math.PI)
          .translate(d3projection([0, 0]))()
          .forEach(function(t) {   // download and display each vector tile
            var tid = tileId(t);
            console.log('need to get tile ' + tid);
            var tileserver = "http://" + ["a", "b", "c"][(t[0] * 31 + t[1]) % 3] + ".tile.openstreetmap.us";
            var tileurlpath = "/vectiles-highroad/" + t[2] + "/" + t[0] + "/" + t[1] + ".json";
            d3.json( tileserver + tileurlpath , function(error, json) {  // this is asynchronous
              // 'json' is a FeatureCollection object containing an array of Feature objects
              json.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }) // sort it so our join-by-index is consistent
                .forEach(function(f) { // for each feature
                  geojsonBucket.add(f);
                  console.log('retrieved tile ' + tid + ', features: ' + json.features.length);
                });
           });
          });
    };

    var loadGeojsonFromLocal = function loadGeojsonFromLocal() {
      geojsonBucket.load();
    };



    var geojsonBucket = (function geojsonBucket() {
      var uid = 'mapdata'; // used when storing and retrieving locally
      var json = {};
      var length = 0;
      var jsonToJoin = {};

      function compareCoordinates(a,b) {
        return ((a[0] === b[0]) && (a[1] === b[1]));
      }

      // if (!Array.prototype.last){
      //     Array.prototype.last = function(){
      //         return this[this.length - 1];
      //     };
      // };

      // if (!Array.prototype.first){
      //     Array.prototype.first = function(){
      //         return this[0];
      //     };
      // };

      // joins two arrays of coordinates, as long as one has a head that matches the other's tail
      function joinCoordinateArrays(a,b,      j,d) {

        if (compareCoordinates(a[0], b[b.length - 1]) === true) {
  // console.log('a: '+a+' b: '+b+' joined: ' + b.splice.apply(a,[0,1].concat(a)));
  // debugger
          // return b.splice.apply(a,[0,1].concat(a));
          return b.splice(0,1).concat(a);
        } else if (compareCoordinates(b[0], a[a.length - 1]) === true) {
  // console.log('a: '+a+' b: '+b+' joined: ' + a.splice.apply(b,[0,1].concat(b)));
  // debugger
          // return a.splice.apply(b,[0,1].concat(b));
          return a.splice(0,1).concat(b);
        } else {
          // console.log("couldn't join arrays. no matching heads and tails. there must be an intermediate array coming.");
          return false;
        }
      }


      return {
        init: function(j) {
          console.log('initing geojsonBucket');
          if (j === undefined) {
            console.log('initing geojsonBucket. no json given, so loading from disk');
            load();
          } else {
            json = j;
          }
          length = Object.keys(json).length;
          console.log('done initing geojsonBucket');
        },
        length: function() {
          return length;
        },
        save: function() {
          localStorage.setObject(uid, json);
        },
        load: function() {
          json = localStorage.getObject(uid);
          // should do some sanity checks on data returned
        },


        add: function add(d) {
          var id = d.id;
          console.log('adding ' + id);

          // if the new feature is a continuation of a feature we already have, join them
          if (json[id] === undefined) {
            json[id] = d;
          } else {
            if (jsonToJoin[id] === undefined) {
              jsonToJoin[id] = [d];
            } else {
              jsonToJoin[id].push(d);
            }
    var x=jsonToJoin[id].length;
        // need to join ways together that have been split over multiple tiles
            // console.log('id already stored (coords ' + json[id].geometry.coordinates.length + '). additional coords: ' + d.geometry.coordinates.length + '. total arrays to join: ' + (1 + jsonToJoin[id].length));
            var arrayJoined = true;
            // we want to loop over our jsonToJoin repeatedly while joins are successful, because the last join may enable the next
            while ((jsonToJoin[id].length > 0) && (arrayJoined === true)) {
    // console.log('in while, jsonToJoin[id].length = '+jsonToJoin[id].length);
              arrayJoined = false;
              for (var i=0,  tot=jsonToJoin[id].length; i < tot; i++) {
    // console.log('in for, tot='+tot+' i='+i);
    // debugger;
                var joined = joinCoordinateArrays(json[id].geometry.coordinates, jsonToJoin[id][i].geometry.coordinates,       json[id], d);
                if (joined.constructor === Array) { // if our join succeeded
    // console.log('woohoo ' + joined + ' totallen = ' + json[id].geometry.coordinates.length);
                  arrayJoined = true;
                  json[id].geometry.coordinates = joined;
    console.log('jsonToJoin[id] len: '+jsonToJoin[id].length+' before');
                  jsonToJoin[id] = jsonToJoin[id].splice(i,1); // remove original copy of the now-joined array
    console.log('jsonToJoin[id] len: '+jsonToJoin[id].length+' after');
    // console.log('woohoo ' + joined + ' totallen = ' + json[id].geometry.coordinates.length);
                // } else {
        // debugger
      }

              }
            }
    console.log('old coords: '+x+' new coords: ' + json[id].geometry.coordinates.length);
    // if (x > 1) debugger
          }
          length += 1;
// debugger;
          this.save();
        },
        remove: function remove(d) {
          delete json[d.id];
          length -= 1;
        },
        reset: function reset() {
          json = {};
        },
        // sorted array
        array: function array() {
          var arr = Object.keys(json).map(function (key) {return json[key];});
          return arr.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; });
        },
        // mutate: function mutate() { // should return mutated data
        //   console.log("not sure how to how to mutate raw json yet. for now renturning raw data.");
        //   var a = this.get();
        //   return this.get();
        // },
        get: function() {
          return this.array();
        },
        debug: function() {
          debugger;
        }
      };
    }());  // end geojsonBucket function





    // 'data' return
    return {
      rawData: rawData,
      geojsonBucket: geojsonBucket,  // module that holds features in current view (should we directly modify contents, or feed into something else?)
      mutatedData: mutatedData,
      mutationSequence: mutationSequence,  // list of changes performed on data

      init: function init() {
        console.log('initing data');
        var defaults = {
          source: 'local'
        };
        var opts = merge(defaults, (arguments[0] || {}));
// debugger;
        if (opts.source == 'server') {
          loadGeojsonFromServer();
        } else {
          loadGeojsonFromLocal();
        }
        console.log("data inited. loaded from " + opts.source);
        return "data inited. loaded from " + opts.source;
      },

      debug: function () {
        debugger;
      },

      loadRawData: function loadRawData(data) {
        rawData = clone(data);
        mutatedData = clone(data); // same object without clone! argh
        return rawData;
      },

      // returns geojsonBucket as array
      getRawData: function getRawData() {
        return geojsonBucket.array();
      },

      getMutatedData: function getMutatedData() {
        geojsonBucket.mutate();  // should actually load data from graph object
        return mutatedData;
      },

      mutate: function mutate() {

        var arr = geojsonBucket.array();
        var del = arr[getRandomInt(0, arr.length)];
        geojsonBucket.remove(del);
        console.log('mutated by removing ' + del.id + '. ' + geojsonBucket.length() + ' paths remain');
      },

      prune: function prune() {
        // debugger;
        var p = mutatedData.pop();
        var action = {
          pruned: p
        };
        mutationSequence.concat(action);
        console.log('pruned ' + p);
        console.log('remaining ' + mutatedData);
        console.log('rawData ' + rawData);
      },

      reset: function reset() {
        mutationSequence = [];
        mutatedData = rawData;
        console.log('reset data to ' + rawData);
      }

    };

  }();






  // Module to draw svg based on data being passed in
  var graphics = function graphics() {
    // Phase1: retrieve the tiles in the view, pass them to the data object
    // Phase1: draw the data from the data object
    // Phase2: add event handling for scrolling and zooming, retrieve new data (and pass it to the data module), and update the display area with modified data from the data module

    var svgClear = function svgClear() {
      svg.selectAll("*").remove();
    };

    var svgDraw = function svgDraw(paths) {
      console.log('drawing ' + paths.length + ' paths');
      svgClear();
      svg.selectAll("path")  // get all the svg paths from this svg grouping
          .data(paths)
        .enter().append("path")
          .attr("class", function(d) { return d.properties.kind; })
          .attr("d", d3path)
          .each(function(f) { // for each feature
            console.log('drawing path with ' + f.geometry.coordinates.length + ' nodes');
          })
          ;
    };

    var svgDrawRaw = function svgDrawRaw() {
      var paths = data.getRawData();
      console.log('drawing ' + paths.length + ' paths from raw data');
      svgDraw(paths);
    };


    var svgDrawMutated = function svgDrawMutated() {
      var paths = data.getMutatedData();
      console.log('drawing ' + paths.length + ' paths from mutated data');
      svgDraw(paths);
    };

    function draw(dataArg) {
        if (dataArg === undefined) {
          console.log('no data passed to draw. defaulting to mutated data (data.getMutatedData)');
          dataArg = illumap.data.getRawData();
        }
        var selection = svg.selectAll("path")
              .data(dataArg)
              // .data([data], function(d) { return ''+d; })
              .attr('d', d3path)
              .each(function(d) {
                console.log('update: ' + d );
              });
        selection.enter().append('path')
              .attr("stroke", "black")
              .attr("fill", "none")
              .attr("stroke-width",2)
              .attr('d',d3path)
              .each(function(d) {
                console.log('enter: ' + d);
              });
        selection.exit().each(function(d) {
          console.log("exit: "+ d);
        });
      }






    return {
      draw: draw,
      svgDrawRaw: svgDrawRaw,
      svgDrawMutated: svgDrawMutated,
      svgClear: svgClear,

      // init: store passed in svg element.
      // draw: take data and draw it, using module parameters
      init: function init() {
        console.log('graphics inited');
        return svg;
      },

      debug: function () {
        debugger;
      },

    }; // end return
  }(); // end graphics



  // Module to run tests
  var test = function test() {
    // var tempdata = [[1,1],[2,2],[2,3],[3,3],[3,4]];

    // var tempmapdata =
    // .data(d3tiler
    //   .scale(d3projection.scale() * 2 * Math.PI)
    //   .translate(d3projection([0, 0])))

    // init: store passed in svg element.
    var init = function init() {
      // debugger;
      illumap.data.init({source: 'local'});
      // illumap.data.init({source: 'local'});
      // illumap.data.init();
      // illumap.data.loadRawData();
      // illumap.updateTiles();
      illumap.graphics.init();
      // illumap.graphics.draw(illumap.data.getRawData());
      illumap.graphics.svgClear();
      illumap.graphics.svgDrawRaw();
// debugger;
    };

    return {
      init: init
    }; // end return
  }(); // end test

// debugger;
  window.addEventListener('load', test.init);

  var debug = function() {
    debugger;
  };

  // API
  return {
    data: data,
    graphics: graphics,
    test: test,
    debug: debug

  };



}(this);


var testbutton = d3.select('#prunebutton')
  .on('click', illumap.data.mutate);
d3.select('#resetbutton')
  .on('click', illumap.data.reset);
d3.select('#drawbutton')
  .on('click', illumap.graphics.draw);

</script>

</body>
</html>
